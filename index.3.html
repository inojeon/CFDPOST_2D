<!DOCTYPE html>
<html>
<head>
  <title>2D CFD POST</title>
</head>
<body>
  
    <div id="container"></div>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <script>  
  var result = {};

  d3.text("./result1/result_002.rlt", function(error, data) {
    if (error) throw error;
    
    result = readCFDData(data); 


    // Structured (n * m) grid of data. Point coordinates are (xgrid, ygrid) 
    var n = result.x_langth , m = result.y_langth;
    var nverts = n*m;
    var values = (result.p);
    var xgrid = (result.x);
    var ygrid = (result.y);
    
    // Obtain centre of grid and scale factors
    var xmin = d3.min(xgrid);
    var xmax = d3.max(xgrid);
    var xmid = 0.5*(xmin+xmax);
    var xrange = xmax-xmin;
        
    var ymin = d3.min(ygrid);
    var ymax = d3.max(ygrid);
    var ymid = 0.5*(ymin+ymax);
    var yrange = ymax-ymin;
        
    var zmin = d3.min(values);
    var zmax = d3.max(values);
    var zmid = 0.5*(zmin+zmax);
    var zrange = zmax-zmin;
        
    var scalefac = 1.2/Math.max(xrange, yrange);
    var scalefacz = 0.5/zrange;
        
    // Use d3 for color scale 
    var color = d3.scaleLinear()
        .domain(d3.extent(values))
        .interpolate(function() { return d3.interpolateRdBu; });
        
    
    // Initialise threejs geometry
    var geometry = new THREE.Geometry(); 
        
    // Add grid vertices to geometry
    for (var k = 0; k < nverts; ++k) {
        var newvert= new THREE.Vector3( (xgrid[k] ) * scalefac, (ygrid[k] ) * scalefac, 0 );
//        var newvert= new THREE.Vector3( (xgrid[k] - xmid) * scalefac, (ygrid[k] - ymid) * scalefac, (values[k] - zmid) * scalefacz);
        geometry.vertices.push(newvert);
    }
        
    // Add cell faces (2 traingles per cell) to geometry
    for (var j = 0; j < m-1; j++){
        for (var i = 0; i < n-1; i++){ 
            var n0 = j*n + i;
            var n1 = n0 + 1;
            var n2 = (j+1)*n + i + 1;
            var n3 = n2 - 1;
            face1= new THREE.Face3(n0,n1,n2);
            face2= new THREE.Face3(n2,n3,n0);
            face1.vertexColors[0]=new THREE.Color(color(values[n0]));
            face1.vertexColors[1]=new THREE.Color(color(values[n1]));
            face1.vertexColors[2]=new THREE.Color(color(values[n2]));
            face2.vertexColors[0]=new THREE.Color(color(values[n2]));
            face2.vertexColors[1]=new THREE.Color(color(values[n3]));
            face2.vertexColors[2]=new THREE.Color(color(values[n0]));
            geometry.faces.push(face1);
            geometry.faces.push(face2);
        }
    }
        
    // Compute normals for shading
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
        
    // Use MeshPhongMaterial for a reflective surface
    var material = new THREE.MeshPhongMaterial( {
        side: THREE.DoubleSide,
        color: 0xffffff,
        vertexColors: THREE.VertexColors,
        specular: 0x050505,
        shininess: 100.,
        emissive: 0x111111,
    });
        
    // Initialise threejs scene
    var scene = new THREE.Scene();
        
    // Add Mesh to scene
    scene.add( new THREE.Mesh( geometry, material ) );
        
    // Create renderer
    var renderer = new THREE.WebGLRenderer({alpha:true, antialias:true}); 
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( 1000, 1000 );
    
    // Set target DIV for rendering
    var container = document.getElementById( 'container' );
    container.appendChild( renderer.domElement );
    
    // Define the camera
    var camera = new THREE.PerspectiveCamera( 45, 1, 0.1, 10 );
    camera.position.z = 2; 
    
    // Add controls 
    var controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.addEventListener( 'change', function(){
        renderer.render(scene,camera); // re-render if controls move/zoom 
    } ); 
    controls.enableZoom = true; 
    
    // Light above
    var light = new THREE.PointLight( 0xffffff);
    light.position.set( 0, 0, 3 );
    scene.add( light );
        
    // Light below
    var light = new THREE.PointLight( 0xffffff);
    light.position.set( 0, 0, -3 );
    scene.add( light );
    
    // Ambient light
    var light = new THREE.AmbientLight( 0x222222 );
    scene.add( light );  
      
    // Make initial call to render scene
    renderer.render( scene, camera );
        
  });
 


  function readCFDData(data){
    var datas = data.trim().split(/[\s,="']+/);
    var mode = 0;

    var colum_val =[];
    var zone = {};
    var zone_val = [];
    var zone_keys = [];
    var trace = {};
    var x_langth, y_langth;
    var r = 0;
    var plotType = '2D';

    if (!datas[0].toLowerCase().match(/^variables/)) {
      var lines = data.split('\n');
    } else { // plot3D type
      for(var i = 0; i < datas.length; i++) {
        if (datas[i].toLowerCase().match(/^variables/)) {
          var j = 0;
          while(!datas[i+1].toLowerCase().match(/^zone/)){
            i = i + 1;
            //console.log(datas[i])
            var replaced = datas[i].replace(/\W*/g,'').toLowerCase();
            //console.log(replaced)
            if ( replaced ) {
              colum_val[j++] = replaced;
            }
          }
        } else if (datas[i].toLowerCase().match('zone')){
          i=i+1;
          var j = 0;
          var key = "";
          var value = "";
          var i_flag = false, j_flag = false;

          //console.log(datas[i]);
          while ( datas[i].replace(/\W+/g,'').match(/^[a-zA-Z]/) ) {
            var key = datas[i].replace(/\W+/g,'').toLowerCase();
            var value = "";
            while ( ! value ) {
              value = datas[++i].replace(/\W+/g,'').toLowerCase();
            }
            if( key.match(/[i]/)){
              zone[key] = parseInt(value);
              i_flag = true;
            } else if( key.match(/[j]/)){
              zone[key] = parseInt(value);
              j_flag = true;

            } else if ( key.match(/[tf]/)) {
              zone[key] = value;
            }

            i++;
          }
          i--;

          if (i_flag && j_flag ) {
            plotType = '3D';
          } else {
            plotType = '2D';


            for (var p = 0; p < colum_val.length; p++) {
              trace[colum_val[p]] = new Array();
            }
          }
        } else {     //read data
          if (plotType == '2D'){
            for (var p = 0; p < colum_val.length; p++) {
              trace[colum_val[p]][r] = parseFloat(datas[i++]);
            }
            i--;
            r++;
          } else if (plotType == '3D') {
            trace['a'] = new Array();
            trace['b'] = new Array();

            var rr=0;

            for (var k = 0; k < zone.j; k++) {
              //console.log(k);
              for (var q = 0; q < zone.i; q++) {
                for (var p = 0; p < colum_val.length; p++) {
                  if ((k==0) && (q==0) ){            // 객체 원소 생성
                    trace[colum_val[p]] = new Array();
                  }
                  if(p==0){
                    trace.a[rr] = q;
                  } else if(p==1) {
                    trace.b[rr] = k;
                  }
                  trace[colum_val[p]][rr] = parseFloat(datas[i++]);
                }
                rr++;
              }
            }
            trace.x_langth = zone.i;
            trace.y_langth = zone.j;

          } else {
            return -1;
          }
        }
      }
      trace.zone = zone;
      trace.varlist = colum_val;
      trace.plotType = plotType;

//        console.log(trace);

      if (trace.plotType.match('2D')) {

        return trace;

      } else if (trace.plotType.match('3D')) {

        return trace;
      } else {
        return -1;
      }
    }
  }
  

  </script>
</body>
</html>